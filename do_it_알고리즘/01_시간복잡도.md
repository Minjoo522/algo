# 시간 복잡도

> 항상 최악의 케이스로 따진다

## 시간 복잡도 표기법

- 주어진 문제를 해결하기 위한 연산 횟수
- 파이썬 : 2,000만 번 ~ 1억 번의 연산을 1초 수행 시간으로 예측 가능

### 시간 복잡도 유형

- 빅 오메가 : 최선
- 빅 세타 : 보통
- 빅 오 : 최악

#### 예제로 확인하기

```python
import random

findNumber = random.randrange(1, 101)

for i in range(1, 101):
    if i == findNumber:
        print(i)
        break
```

- 빅 오메가 : 1번(한번에 찾을 때)
- 빅 세타 : N/2번
- 빅 오 : N(마지막에 찾을 때)

> 시간 복잡도는 데이터의 크기와 밀접한 관련이 있다.

### 연산 횟수 계산 방법

- 1초에 2,000만 번 연산하는 것을 기준으로 생각
- 데이터의 크기가 가장 클 때를 기준
- `연산 횟수 = 알고리즘 시간 복잡도 n값에 데이터의 최대 크기를 대입하여 도출`

### 시간 복잡도를 바탕으로 코드 로직 개선

#### 시간 복잡도 도출 기준

1. 상수는 시간 복잡도 계산에서 제외
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준

```python
# 연산 횟수 = N
N = 100000
cnt = 1

for i in range(N):
    print('연산 횟수 ' + str(cnt))
    cnt += 1
```

```python
# 연산 횟수 = 3N
N = 100000
cnt = 1

for i in range(N):
    print('연산 횟수 ' + str(cnt))
    cnt += 1

for i in range(N):
    print('연산 횟수 ' + str(cnt))
    cnt += 1

for i in range(N):
    print('연산 횟수 ' + str(cnt))
    cnt += 1
```

- N, 3N ➡️ 차이 거의 없음(무시) ➡️ 같은 시간 복잡도

```python
N = 100000
cnt = 1

for i in range(N):
    for j in range(N):
        print('연산 횟수 ' + str(cnt))
        cnt += 1
```

- ⬆️ 얘는 N<sup>2</sup>
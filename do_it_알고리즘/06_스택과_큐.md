# 스택과 큐

- 리스트에서 조금 더 발전한 자료구조

## 스택

- 후입선출(Last In First Out) : 가장 마지막에 삽입된 데이터가 가장 먼저 나오는 구조
- top: 삽입과 삭제가 일어나는 위치
- append(data) : 새로운 데이터 삽입
- pop() : top 위치에 있는 데이터를 삭제하고 확인
- [-1]: top 위치에 있는 데이터를 단순 확인
- DFS, 백트래킹
- 재귀 함수 알고리즘 원리와 일맥상통

## 큐

- 선입선출(First In First Out) : 먼저 들어온 데이터가 먼저 나가는 구조
- 파이썬에서는 `deque`를 이용하여 구현
    - `list`도 가능하긴 함 (deque가 시간 복잡도가 더 빠름)
- rear : 큐에서 가장 끝 데이터
- front : 가장 앞 데이터
- append(data) : rear 부분에 새로운 데이터 삽입
- popleft() : front 부분에 있는 데이터를 삭제하고 확인
- [0] : 맨 앞에 있는 데이터 확인
- BFS

## 우선순위 큐

- 값이 들어간 순서와 상관 없이 우선순위가 높은 데이터가 먼저 나오는 자료구조
- `heap` 이용해 구현

### 예제: boj_17298

- 반복문 (❌ - 시간 초과)
- 오큰수가 아직 정해지지 않았는데 나보다 작은 애를 찾기 (❌ - 시간 초과)
- `stack` : `인덱스` 저장
    - 스택에 새로 들어오는 수가 top에 존재하는 수보다 크면 그 수는 오큰수가 된다
    - 오큰수를 구한 후 수열에서 오큰수가 존재하지 않는 숫자게 -1을 출력해야 한다

```markdown
1. 스택이 채워져 있고, A[index] > A[top]인 경우 pop한 `인덱스`를 이용하여 정답 수열에 오큰수를 저장
    - pop은 조건을 만족하는 동안 계속 반복
2. 현재 `인덱스`를 스택에 push하고 다음 인덱스로 넘어감
3. 과정 1 ~ 2를 수열 길이만큼 반복한 다음 현재 스택에 남아 있는 인덱스에 -1을 저장
```
```python
n = int(input())
A = list(map(int, input().split()))
ans = [0] * n
my_stack = []

for i in range(n):
    while my_stack and A[my_stack[-1]] < A[i]:
        ans[my_stack.pop()] = A[i]
    my_stack.append(i)

while my_stack:
    ans[my_stack.pop()] = -1

print(*ans)
```